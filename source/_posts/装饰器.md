---
title: 装饰器
excerpt: 实现一个装饰器，使其可以是带参数的装饰器，也可以是不带参数的装饰器
date: 2021-05-11 11:39:38
tags:
---

## 什么是装饰器
装饰器是一个能返回函数的高阶函数。它以@符号的形式装饰一个函数，可以给被装饰的函数增强功能。比如可以统计这个函数的执行时间，运行函数的时候打日志等。

## 实现一个不带参数的装饰器
不带参数的装饰器用两层函数来实现，它对于被装饰函数 f 所做的事情是 f = metric(f)

    import time
    from functools import wraps
    def metric(func):
        @wraps(func)
        def wrapper(*args, **kw):
            start = time.perf_counter()
            res = func(*args, **kw)
            end = time.perf_counter()
            cost = (end - start) * 1000
            print(f"{func.__name__} finished in {cost}ms")
            return res
        return wrapper
    
    @metric
    def slow(x, y):
        time.sleep(0.1234)
        return x + y

    @metric
    def fast(x, y, z):
        time.sleep(0.0012)
        return x * y * z
    
    def test_deco():
        s = slow(1, 3)
        f = fast(3, 4, 5)
        assert s == 4
        assert f == 60
    
    test_deco()
这段代码的执行结果是
    
    slow finished in 138.6591ms
    fast finished in 14.628799999999998ms

## 实现一个带参数的装饰器
带参数的装饰器用三层函数来实现。它对于被装饰函数 f 所做的事情是 f = log('INFO')(f)
    
    def log(level):
        def decorator(func):
            def wrapper(*args, **kw):
                print(f'{level} begin call')
                func(*args, **kw)
                print(f'{level} end call')
            return wrapper
        return decorator
    
    @log('INFO')
    def f():
        pass
    
    f()
这段代码的执行结果是

    INFO begin call
    INFO end call

## 装饰器的执行过程
拿上面的带参数的装饰器来举例子，首先调用 log('INFO'),返回 decoorator, 然后调用 decorator函数，传入参数 func，返回 wrapper函数，再调用wrapper函数，在wrapper 函数里调用被装饰的函数。
因此 log 的返回值需要是 decorator, 才能继续调用 decorator，decorator 的返回值需要时 wrapper，才能继续调用 wrapper 函数，至于 wrapper 函数的返回值，我觉得不是必要有返回值，依据下面是如何调用被装饰的函数 f 的，如果要用 f 的返回值，那么就 res = func(*args, **kw), wrapper 函数返回 res, 如果用不到，wrapper函数可以不返回（当然不返回也有默认返回值是 None）。

以一段代码来看下：

    def log(level):
        def decorator(func):
            def wrapper(*args, **kw):
                print('3')
                print(f'{level} begin call')
                func(*args, **kw)
                print('5')
                print(f'{level} end call')
            print('2')
            return wrapper
        print('1')
        return decorator
    
    @log('INFO')
    def f():
        print('4')
        pass
    
    f()
执行结果为：

    1
    2
    3
    INFO begin call
    4
    5
    INFO end call

## functools.wraps
不管是两层还是三层，都有一个问题，就是被装饰的函数的名字会变成 wrapper, 看下面这段代码，最后打印被装饰的函数 f 的名字由 f 变成了 wrapper, 原因待写......

    def metric(func):
        def wrapper(*args, **kw):
            start = time.perf_counter()
            func(*args, **kw)
            end = time.perf_counter()
            cost = (end - start) * 1000
            print(f"{func.__name__} finished in {cost}ms")
        return wrapper

    @metric
    def f():
        pass

    f()
    print(f.__name__)   #  it will print wrapper
可以用内置函数工具 functools.wraps 来解决这个问题，functools.wraps 也是一个装饰器，它的作用是使被装饰的函数保留其原有的函数信息。它本质上做的事情是 wrapper.\_\_name__ = func.\_\_name__

#### Note
博客学习自廖雪峰的网站，是自己的记录总结。
This is [廖雪峰的官方网站](https://www.liaoxuefeng.com/wiki/1016959663602400/1017451662295584#0)。

## 课后作业
能否写出一个 @log 的装饰器，使它同时支持下面两种装饰

    @log
    def f():
        pass

    @log('execute')
    def f():
        pass

answer:
    注意上面是不带参数的装饰器，是 @log, 不等于 @log()

    def log(text):
        def decorator(func):
            def wrapper(*args, **kw):
                if callable(text):
                    print(f'begin call {func.__name__}')
                else:
                    print(f'{text} begin call {func.__name__}')
                print('end call')
            return wrapper
        if callable(text):
            return decorator(text)
        return decorator
    
    @log
    def f():
        pass

    @log('execute')
    def f1():
        pass
        
执行结果为：
    
    begin call f
    end call
    execute begin call f1
    end call

    