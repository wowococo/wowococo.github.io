<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Python thread</title>
    <link href="/2021/04/23/Python-thread/"/>
    <url>/2021/04/23/Python-thread/</url>
    
    <content type="html"><![CDATA[<h3 id="多核"><a href="#多核" class="headerlink" title="多核"></a>多核</h3><p>对于 Python 而言，因为有 GIL 锁的原因，每次 CPU 只能运行一个线程，所以即使是多核，Python 的多线程也只能用一个，发挥不出多核的优势。</p><h3 id="既然每次CPU只能跑一个线程，那Python多线程的优势在哪？"><a href="#既然每次CPU只能跑一个线程，那Python多线程的优势在哪？" class="headerlink" title="既然每次CPU只能跑一个线程，那Python多线程的优势在哪？"></a>既然每次CPU只能跑一个线程，那Python多线程的优势在哪？</h3><p>优势在于 IO 密集型的线程，可以利用 IO 阻塞等待时的空闲时间去执行另一个线程，Python 在 IO 阻塞的时候会释放 GIL 锁，然后 CPU 就切换到其他线程，等于说是这个线程的 IO 操作和另一个线程的 CPU 计算同时进行的，所以对于 IO 密集型的线程，Python 多线程速度还是快很多的。</p><p>CPU 密集型下，由于一个 CPU 时间片下只能运行一个线程，所以使用多线程并不能加快计算速度。相反可能因为频繁的切换线程，使速度更慢。</p>]]></content>
    
    
    
    <tags>
      
      <tag>thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/2021/02/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2021/02/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h4 id="1653-使字符串平衡的最少删除次数"><a href="#1653-使字符串平衡的最少删除次数" class="headerlink" title="1653. 使字符串平衡的最少删除次数"></a><a href="https://leetcode-cn.com/problems/minimum-deletions-to-make-string-balanced/">1653. 使字符串平衡的最少删除次数</a></h4><ol><li><p>找出子问题</p><p>设大问题是big，字符串[:-1]的最少删除次数是子问题small，big 的结果由small 与最后一个字符共同作用。然后子问题继续拆分成子问题…</p></li><li><p>写状态转移方程</p><p>a:</p><p>​    big_end_a = small_end_a</p><p>​    big_end_b = small_end_b + 1    # 需要删掉最后的a</p><p>b:</p><p>​    big_end_b = min(small_end_a, small_end_b)</p><p>​    big_end_a = small_end_a + 1</p></li></ol><ol start="3"><li>Python 实现<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minimumDeletions</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; int:</span><br>    end_a, end_b = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> s:<br>        <span class="hljs-keyword">if</span> char == <span class="hljs-string">&quot;a&quot;</span>:<br>            end_b = end_b + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            end_b = <span class="hljs-built_in">min</span>(end_a, end_b)<br>            end_a = end_a + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(end_a, end_b)<br><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LRU 实现</title>
    <link href="/2021/01/31/LRU%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/01/31/LRU%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>思路：</p><p>Python dict + 双向链表</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>:</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, k, v)</span></span><span class="hljs-symbol">:</span><br><span class="hljs-keyword">self</span>.key = k<br><span class="hljs-keyword">self</span>.val = v<br><span class="hljs-keyword">self</span>.prev = None<br><span class="hljs-keyword">self</span>.<span class="hljs-keyword">next</span> = None<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span>:</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, capacity)</span></span><span class="hljs-symbol">:</span><br><span class="hljs-keyword">self</span>.capacity = capacity<br><span class="hljs-keyword">self</span>.dic = dict()<br><span class="hljs-keyword">self</span>.head = Node(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">self</span>.tail = Node(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">self</span>.head.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">self</span>.tail<br><span class="hljs-keyword">self</span>.tail.prev = <span class="hljs-keyword">self</span>.head<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, key)</span></span><span class="hljs-symbol">:</span><br><span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span>.<span class="hljs-symbol">dic:</span><br>n = <span class="hljs-keyword">self</span>.dic[key]<br><span class="hljs-keyword">self</span>.remove(n)<br><span class="hljs-keyword">self</span>.add(n)<br><span class="hljs-keyword">return</span> n.val<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, key, value)</span></span><span class="hljs-symbol">:</span><br><span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span>.<span class="hljs-symbol">dic:</span><br>n = <span class="hljs-keyword">self</span>.dic[key]<br><span class="hljs-keyword">self</span>.remove(n)<br>n = Node(key, value)<br><span class="hljs-keyword">self</span>.add(n)<br><span class="hljs-keyword">self</span>.dic[key] = n<br><span class="hljs-keyword">if</span> len(<span class="hljs-keyword">self</span>.dic) &gt; <span class="hljs-keyword">self</span>.<span class="hljs-symbol">capacity:</span><br>_n = <span class="hljs-keyword">self</span>.tail.prev<br><span class="hljs-keyword">self</span>.remove(_n)<br>del <span class="hljs-keyword">self</span>.dic[_n.key]<br><br><span class="hljs-comment"># 向头结点后插入结点</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, node)</span></span><span class="hljs-symbol">:</span><br>node.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">self</span>.head.<span class="hljs-keyword">next</span><br><span class="hljs-keyword">self</span>.head.<span class="hljs-keyword">next</span>.prev = node<br><br><span class="hljs-keyword">self</span>.head.<span class="hljs-keyword">next</span> = node<br>node.prev = <span class="hljs-keyword">self</span>.head<br><br><span class="hljs-comment"># 删除链表中某个节点</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, node)</span></span><span class="hljs-symbol">:</span><br>p = node.prev<br>n = node.<span class="hljs-keyword">next</span><br>p.<span class="hljs-keyword">next</span> = n<br>n.prev = p<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode 双向链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
